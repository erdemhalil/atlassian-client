# Do not edit this file directly. It has been autogenerated from
# atlassian\core\async_client.py
from __future__ import annotations

import time
from collections.abc import Mapping
from typing import Any

import httpx

from .auth import AuthBase
from .exceptions import raise_for_status


class BaseClient:
    def __init__(
        self,
        *,
        base_url: str,
        auth: AuthBase | None = None,
        timeout: float = 30.0,
        max_retries: int = 3,
        retry_backoff_factor: float = 0.5,
        verify_ssl: bool = True,
        transport: httpx.BaseTransport | None = None,
    ) -> None:
        if max_retries < 0:
            raise ValueError("max_retries must be >= 0")
        if retry_backoff_factor < 0:
            raise ValueError("retry_backoff_factor must be >= 0")

        self.auth = auth
        self.max_retries = max_retries
        self.retry_backoff_factor = retry_backoff_factor
        self._client = httpx.Client(
            base_url=base_url,
            timeout=timeout,
            verify=verify_ssl,
            transport=transport,
        )

    def __enter__(self) -> BaseClient:
        return self

    def __exit__(self, exc_type: Any, exc: Any, tb: Any) -> None:
        self.close()

    def close(self) -> None:
        self._client.close()

    def _request(
        self,
        method: str,
        path: str,
        *,
        params: Mapping[str, Any] | None = None,
        json: Any = None,
        data: Any = None,
        headers: Mapping[str, str] | None = None,
    ) -> httpx.Response:
        for attempt in range(self.max_retries + 1):
            request = self._client.build_request(
                method,
                path,
                params=params,
                json=json,
                data=data,
                headers=headers,
            )
            if self.auth is not None:
                request = self.auth.apply(request)

            response = self._client.send(request)
            if not self._is_retryable(response.status_code):
                break

            if attempt >= self.max_retries:
                break

            backoff = self.retry_backoff_factor * (2**attempt)
            time.sleep(backoff)

        raise_for_status(response)
        return response

    @staticmethod
    def _is_retryable(status_code: int) -> bool:
        return status_code == 429 or status_code >= 500
